MESI协议解决了缓存不一致问题，但是这与内存一致性不属于同一个问题。缓存的一致性只保证某个核心的缓存值更新后，可以正确传播到其他核心的缓存
之中。而内存一致性更多是程序员的一种要求，粗略的说，它要求一段连续的指令被多个核心执行时是顺序执行的（或者即使指令重排后效果也与顺序执行
一样），此外，内存可见性属于JVM层面的东西，通常网络上文章中所说的线程自身“缓存”不一致与缓存一致性问题中的缓存不属于一个层面。

# 缓存一致性
现代PC机基本都包含多个处理器，CPU 的读 / 写（以及取指令）单元正常情况下甚至都不能直接访问内存——这是物理结构决定的，在处理器和内存之间
处理器缓存（处理器缓存拥有prefetch功能，它保证了CPU需要的数据大部分约90%预先已经由处理器缓存从内存从读入）。

如果只进行读操作，那么事情很简单，所有级别的缓存（多级缓存下）都遵守：
> 在任意时刻，任一级别的缓存中的缓存段的内容，与内存中对应的内容相等。

但是在写操作时，事情就变得复杂起来，有两种基本的写模式（现代PC基本都是write-back模式）：
- write-through:把需要写的内容写入缓存中，如果缓存中对应的段已经有内容（证明需要更新），那么更新内容（或者直接让这个段失效），写入内存。

- write-back:把需要写的内容写入缓存中，如果缓存中对应的段已经由内容，那么更新内容，并做一个标记。在某一时刻，这个段需要丢弃，但由于标记
的原因，提示缓存需要把当前的段的内容先写入到内存对应的地方，然后才能丢弃这个段。

如果只有一个核心在工作，那么一切都是没问题的（在这种情况下的伪多线程），如果有多个核心，那么就会有一个问题：如果某个 CPU 缓存段中对应的
内存内容被另外一个 CPU 偷偷改了，会发生什么？

答案是什么也不会发生，正是由于什么也不会发生，所以出现了缓存不一致，注意这里出现问题的原因是每个核心都拥有自己的多级缓存，而不是因为多个
核心本身导致的（例如可以设计多个核心共享一个缓存，这当然会有额外的问题）。

为了解决这一问题，通常的做法是snooping，当一个某个核心的缓存尝试去读写内存时，其他的核心都会收到通知，写操作会表明其他核心的缓存失效，但
这里有个问题在于，即便这个核心尝试去写，但是由于write-back机制的存在，内存并不会即时收到最新的值。通过MESI协议可以解决这个问题。

# 内存一致性
如上所述，缓存的一致性只保证某个核心的缓存更新后，可以正确传播到其他核心的缓存之中。而内存一致性则期望解决连续的指令即便被重排后也与顺序
执行的效果一致（当然最粗糙的做法就是禁止重排），这其中包括原子性、有序性、可见性。